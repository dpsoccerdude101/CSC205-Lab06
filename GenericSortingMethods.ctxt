#BlueJ class context
comment0.target=GenericSortingMethods
comment0.text=\r\n\ Implement\ the\ generic\ versions\ of\ sorting\ algorithms\r\n\ Selection\ Sort,\ Insertion\ Sort\ and\ Bubblesort\r\n\ Using\ the\ Comparable\ Interface\r\n\ \r\n\ @author\ T.M.\ Rao\r\n\ @version\ September\ 2018\r\n\ \r\n
comment1.params=a\ i\ j
comment1.target=void\ swap(java.lang.Comparable[],\ int,\ int)
comment1.text=\r\n\ swap\ procedure\r\n\ @param\ Comparable[]\ a\ --\ the\ array\ in\ which\ the\ swapping\ is\ done\r\n\ @param\ i\r\n\ @param\ j\ \ --\ the\ two\ locations\ in\ the\ array\ that\ will\ be\ swapped\r\n
comment10.params=a\ first\ last
comment10.target=int\ partition(java.lang.Comparable[],\ int,\ int)
comment10.text=\r\n\ This\ is\ a\ private\ supporting\ method\ for\ quicksort.\ It\ just\ does\r\n\ the\ partitionaing\ of\ the\ array.\r\n\ @param\ first\:\ the\ start\ index\ of\ the\ sub-array\r\n\ @param\ last\:\ the\ end\ index\ of\ the\ sub-array\r\n
comment11.params=a\ x
comment11.target=int\ linSearch(java.lang.Comparable[],\ java.lang.Comparable)
comment11.text=\r\n\ The\ linear\ search\ (sequential\ search\ method.\ If\ the\ array\ is\ not\r\n\ sorted,\ this\ is\ the\ only\ way\ you\ can\ search.\r\n\ @param\ Comparable[]\ a\ --\ the\ array\ in\ which\ we\ are\ searching\r\n\ @param\ x\ --\ The\ value\ that\ we\ are\ searching\ for\r\n\ Time\ Complexity\:\ O(N)\r\n
comment12.params=a\ x
comment12.target=int\ binSearch(java.lang.Comparable[],\ java.lang.Comparable)
comment12.text=\r\n\ binary\ search\ method.\ This\ will\ work\ only\ if\ the\ array\ is\ sorted.\r\n\ @param\ Comparable[]\ a\ --\ the\ array\ in\ which\ we\ are\ searching\r\n\ @param\ x\ --\ The\ value\ that\ we\ are\ searching\ for\r\n\ Time\ complexity\ O(log\ N)\r\n
comment13.params=a\ start1\ start2\ end2
comment13.target=void\ merge(java.lang.Comparable[],\ int,\ int,\ int)
comment13.text=\r\n\ It\ is\ assumed\ that\:\r\n\ Two\ parts\ of\ the\ array\ a\:\ a[start1]\ to\ a[start2-1]\ and\ \r\n\ a[start2]\ to\ a[end2]\ are\ sorted.\ end2\ >\=\ start2\ >\=\ start1\r\n\ This\ will\ merge\ those\ two\ parts\ to\ make\ one\ long\r\n\ sorted\ part\ between\ a[start1]\ to\ a[end2]\r\n
comment14.params=a
comment14.target=void\ mergeSort(java.lang.Comparable[])
comment14.text=\r\n\ This\ is\ the\ top-level\ call\ to\ the\ merge\ sort\ algorithm\r\n\ @param\ a\:\ the\ array\ to\ be\ sorted\r\n
comment15.params=a\ start\ end
comment15.target=void\ mergeSort(java.lang.Comparable[],\ int,\ int)
comment15.text=\r\n\ This\ is\ the\ recursive\ method\ that\ actually\ sorts\r\n
comment16.params=
comment16.target=int\ getNumComps()
comment2.params=a\ k
comment2.target=int\ select(java.lang.Comparable[],\ int)
comment2.text=\r\n\ findSmallestLoc\ --\ Locates\ the\ smallest\ element\ in\ the\ array\ between\ \r\n\ array\ positions\ start\ and\ end\r\n\ @param\ int[]\ a\ --\ the\ array\ in\ which\ the\ locating\ is\ to\ be\ done\r\n\ @param\ start\ --\ starting\ location\ \r\n\ @param\ end\ --\ end\ location\r\n\ This\ is\ called\ by\ the\ selectionSort\ method\r\n
comment3.params=a
comment3.target=void\ selectionSort(java.lang.Comparable[])
comment3.text=\r\n\ The\ selection\ sort\ method\:\ sorts\ the\ given\ unsorted\ array\ a\r\n\ @param\ Comparable[]\ a\ --\ the\ array\ to\ be\ sorted\r\n\ calls\:\ findSmallestLoc\ and\ swap\ methods\r\n\ Time\ Complexity\:\ O(N\ **\ 2)\r\n
comment4.params=a
comment4.target=void\ insertionSort(java.lang.Comparable[])
comment4.text=\r\n\ The\ insertion\ sort\ method\:\ Sorts\ the\ given\ array\ a\r\n\ \r\n\ @param\ Comparable[]\ a\ --\ the\ array\ to\ be\ sorted\r\n\ calls\:\ insert\ and\ swap\ methods\r\n\ Time\ Complexity\:\ O(N\ **\ 2)\r\n
comment5.params=a\ x\ end
comment5.target=void\ insert(java.lang.Comparable[],\ java.lang.Comparable,\ int)
comment5.text=\r\n\ The\ insert\ method.\ It\ is\ assimed\ that\ the\ part\ of\ the\ array\ between\ \r\n\ position\ 0\ and\ position\ end\ is\ sorted.\ It\ inserts\ a\ new\ element\ x\ into\ \r\n\ the\ array,\ by\ moving\ other\ elements\ down\ and\ making\ space\ for\ the\ new\ \r\n\ element.\ It\ maintains\ the\ increasing\ order\ of\ the\ array.\r\n\ @param\ Comparable[]\ a\ -\ the\ sorted\ array\ into\ which\ insertion\ is\ made\r\n\ @param\ x\ --\ the\ integer\ that\ is\ to\ be\ inserted\r\n\ @param\ end\ --\ array\ is\ assumed\ to\ be\ sorted\ from\ 0\ to\ end\r\n\ \r\n\ Called\ by\:\ the\ insertionSort\ method\r\n
comment6.params=a\ end
comment6.target=boolean\ pass(java.lang.Comparable[],\ int)
comment6.text=\r\n\ pass\:\ It\ makes\ one\ "pass"\ over\ the\ data,\ starting\ at\ position\ 0\ up\ to\r\n\ position\ end.\ It\ compares\ a[0]\ with\ a[1],\ a[1]\ with\ a[2]\ ...\ and\r\n\ a[end-1]\ with\ a[end],\ and\ makes\ a\ swap\ if\ necessary.\ In\ case\ it\ swaps\r\n\ it\ will\ record\ that\ fact\ by\ setting\ didSwap\ to\ true.\ This\ is\ what\ is\ \r\n\ returned\ by\ the\ method.\r\n\ @param\ Comparable[]\ a\ --\ the\ array\ to\ be\ sorted\r\n\ @param\ end\ --\ 0\ to\ end\ is\ the\ part\ of\ the\ array\ to\ focus\ on.\ \r\n\ The\ elements\ at\ positions\ end+1\ ...\ will\ be\ sorted.\r\n
comment7.params=a
comment7.target=void\ bubbleSort(java.lang.Comparable[])
comment7.text=\r\n\ The\ bubblesort\ method.\ \ It\ makes\ as\ many\ "pass"es\ as\ needed\ over\ the\r\n\ array\ until\ it\ is\ sorted.\ \r\n\ @param\ Comparable[]\ a\ --\ the\ array\ to\ be\ sorted\r\n\ Time\ Complexity\:\ O(N\ **\ 2)\r\n
comment8.params=a
comment8.target=void\ quickSort(java.lang.Comparable[])
comment8.text=\r\n\ This\ is\ the\ main\ quicksort\ method.\ It\ just\ sets\ the\ parameters\r\n\ properly\ and\ calls\ another\ quicksort\ method\ to\ sort\ it\r\n
comment9.params=a\ first\ last
comment9.target=void\ quickSort(java.lang.Comparable[],\ int,\ int)
comment9.text=\r\n\ This\ is\ the\ recursive\ quicksort\ method.\ It\ first\ partitions\ the\r\n\ array\ into\ two\ parts\ such\ that\ all\ elements\ in\ the\ first\ part\r\n\ are\ less\ than\ all\ elements\ in\ the\ second\ part.\ It\ then\ recursively\r\n\ calls\ itself\ on\ both.\r\n\ @param\ Comparable[]\ a\ --\ the\ array\ to\ be\ sorted\r\n\ Worst\ Case\ Time\ Complexity\:\ O(N\ **\ 2)\r\n\ Average\ case\:\ O(N\ log\ N)\r\n
numComments=17
